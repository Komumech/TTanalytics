<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Interactive Text</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- We'll use a pre-loaded font from a CDN for simplicity -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #1a1a1a;
            font-family: 'Inter', sans-serif;
        }

        #canvas-container {
            width: 80vw;
            height: 80vh;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <script>
        // --- Global variables for scene, camera, and renderer ---
        let scene, camera, renderer;
        let textMesh;
        let mouseX = 0, mouseY = 0;

        // The text content for the 3D model
        const textContent = "A I";

        // Define the colors from the provided theme for interpolation
        const vibrantBlue = new THREE.Color(0x002fff);
        const darkBlue = new THREE.Color(0x15028f);
        const white = new THREE.Color(0xffffff);

        // --- Initialization function ---
        function init() {
            const container = document.getElementById('canvas-container');

            // 1. Create the scene with a subtle fog effect
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            scene.fog = new THREE.Fog(0x1a1a1a, 1, 15);

            // 2. Create the camera
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.z = 6;

            // 3. Create the renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // 4. Add multiple lights for a more beautiful effect
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const pointLight1 = new THREE.PointLight(0xff00ff, 1.5);
            pointLight1.position.set(5, 5, 5);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0x00ffff, 1.5);
            pointLight2.position.set(-5, -5, -5);
            scene.add(pointLight2);

            // 5. Load the font and create the 3D text
            const fontLoader = new THREE.FontLoader();
            fontLoader.load('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/gentilis_regular.typeface.json', function (font) {
                const textGeometry = new THREE.TextGeometry(textContent, {
                    font: font,
                    size: 2,
                    height: 0.5,
                    curveSegments: 12,
                    bevelEnabled: true,
                    bevelThickness: 0.1,
                    bevelSize: 0.08,
                    bevelOffset: 0,
                    bevelSegments: 10 // Increased segments for smoother edges
                });

                textGeometry.center();

                const textMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    roughness: 0.4,
                    metalness: 0.2
                });
                textMesh = new THREE.Mesh(textGeometry, textMaterial);
                scene.add(textMesh);
            });

            // 6. Handle window resizing
            window.addEventListener('resize', onWindowResize, false);

            // 7. Handle mouse movement for interaction
            document.addEventListener('mousemove', onDocumentMouseMove, false);

            // Start the animation loop
            animate();
        }

        // --- Resizing handler ---
        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // --- Mouse movement handler ---
        function onDocumentMouseMove(event) {
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();

            // Normalize mouse position relative to the container div
            mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }

        // --- Animation loop ---
        function animate() {
            requestAnimationFrame(animate);

            if (textMesh) {
                // Adjust text rotation based on mouse position for a slight tilt effect
                const tiltFactor = 0.2; // Reduced tilt factor for a smoother transition
                textMesh.rotation.y += (mouseX * tiltFactor - textMesh.rotation.y) * 0.05;
                textMesh.rotation.x += (mouseY * tiltFactor - textMesh.rotation.x) * 0.05;

                // Create a temporary color object for interpolation
                const tempColor = new THREE.Color();

                // Interpolate between the two blue colors based on mouseX
                tempColor.lerpColors(vibrantBlue, darkBlue, (mouseX + 1) / 2);

                // Interpolate this result with white based on mouseY
                textMesh.material.color.lerpColors(tempColor, white, (mouseY + 1) / 2);
            }

            renderer.render(scene, camera);
        }

        // Start the application when the window loads
        window.onload = init;
    </script>
</body>
</html>
